{
  "success": true,
  "data": [
      {
          "id": "5aae1cc8f5dfc27d7ad98909",
          "author_id": "4efc278525fa69ac69000013",
          "tab": "share",
          "content": "<div class=\"markdown-text\"><blockquote>\n<p>更新：公测版本已经上线，请访问 <a href=\"http://egg.cnodejs.org/\">http://egg.cnodejs.org/</a> ，如遇到任何问题，请提交issue <a href=\"https://github.com/cnodejs/egg-cnode/issues\">https://github.com/cnodejs/egg-cnode/issues</a> ，谢谢各位。</p>\n</blockquote>\n<p>在近期，经过社区的小伙伴们的一起努力下，我们基于 Egg.js 将 nodeclub 进行了重写，重写后的代码仓库位于 <a href=\"https://github.com/cnodejs/egg-cnode\">https://github.com/cnodejs/egg-cnode</a> 。</p>\n<p>原版的 nodeclub 是 2012 年左右，在淘宝实习的某个同学实现的，当时的情况下，几乎没有多少人有过 Node.js 开发真实项目的经验，因此，该项目也存在诸多稚嫩之处，曾经也被 ITeye 的大佬批判过。</p>\n<p>后来在 alsotang、题叶等人的维护下，CNode 经历过一次较大的重构，但那次重构没有对原来的项目进行根本性的改动，重点是用户体验层面的改动。因此 nodeclub 依然保持着比较古老的方式，express + ejs + mongoose 等。原项目缺乏一些工程性的问题：</p>\n<ol>\n<li>基于 Callback 回调的风格，在维护上较为困难。</li>\n<li>没有健壮的进程守护机制，纯粹依靠 PM2 。</li>\n<li>目前该项目运行时也是单机模式，没有更好的可用性。</li>\n</ol>\n<p>本次我们基于 ES 8、Egg 框架，在不改写业务逻辑，不改写 UI 、交互的前提下，对该项目完成了重写。重写之后的 egg-cnode 具有更好的特性，尤其是在可维护性上，有极大程度上的改进，在测试覆盖率方面，以更少的代码量实现了更高的覆盖率。重写过程历时 3 个礼拜，贡献人数 10 人，以社区协作的形式完成。</p>\n<p>我们将在稍后的一个时间将新的版本进行上线测试，也欢迎大家关注我们新的代码仓库。最后感谢：<a href=\"/user/sinchang\">@sinchang</a>、<a href=\"/user/thonatos\">@thonatos</a>、<a href=\"/user/lqs469\">@lqs469</a> 等人参与的贡献。欢迎大家继续关注我们的项目。</p>\n</div>",
          "title": "【公测中】基于 Egg 的 CNode 社区",
          "last_reply_at": "2018-04-04T01:55:47.521Z",
          "good": false,
          "top": true,
          "reply_count": 75,
          "visit_count": 6361,
          "create_at": "2018-03-18T08:01:12.833Z",
          "author": {
              "loginname": "JacksonTian",
              "avatar_url": "https://avatars3.githubusercontent.com/u/327019?v=4&s=120"
          }
      },
      {
          "id": "5abda42674fe2526d62220d4",
          "author_id": "4efc278525fa69ac69000013",
          "tab": "share",
          "content": "<div class=\"markdown-text\"><p>RT。</p>\n</div>",
          "title": "请不要再发薅羊毛帖子",
          "last_reply_at": "2018-04-03T10:58:45.010Z",
          "good": false,
          "top": true,
          "reply_count": 10,
          "visit_count": 1522,
          "create_at": "2018-03-30T02:42:46.752Z",
          "author": {
              "loginname": "JacksonTian",
              "avatar_url": "https://avatars3.githubusercontent.com/u/327019?v=4&s=120"
          }
      },
      {
          "id": "5ab34443e7b166bb7b9ecd06",
          "author_id": "596a2b5edb0b6aec18a28569",
          "tab": "share",
          "content": "<div class=\"markdown-text\"><p>加入cnodejs社区也快1年了，没对社区做过什么贡献，看到社区要公测，刚好自己在公司使用node.js做自动化测试。\n这次我要对社区贡献一套UI自动化代码，别人如果想自己搭建一套社区的话，可以直接运行这套UI自动化代码来检查UI功能。\n平时工作时间比较忙，所以本周日我计划要做如下的事情，\n为了让大家都能看懂我的代码，我会使用行为驱动测试的方式来写代码，完成之后的代码大致如下：\n<img src=\"//dn-cnode.qbox.me/FpAr57XACJfit4rzN4sa2BBulYUj\" alt=\"image.png\">\n可以通过查阅文字描述了解测试的功能点。</p>\n<p>现在我想拉个微信群，如果各位有兴趣，我们可以一起来做。不会写代码也没有关系，可以帮助我们来写测试用例，或者给我们写的测试用例提建议。\n<img src=\"//dn-cnode.qbox.me/FlVUhc1vFM8HAnb0jH1hRHfT6Nu5\" alt=\"微信图片_20180322133956.png\"></p>\n</div>",
          "title": "为社区做贡献，帮社区写自动化测试代码",
          "last_reply_at": "2018-03-29T08:45:54.750Z",
          "good": false,
          "top": true,
          "reply_count": 25,
          "visit_count": 2790,
          "create_at": "2018-03-22T05:50:59.209Z",
          "author": {
              "loginname": "imzengyang",
              "avatar_url": "https://avatars1.githubusercontent.com/u/22312483?v=4&s=120"
          }
      },
      {
          "id": "5ac43f8c37f5d1510f57c898",
          "author_id": "5ab9b37753203c39ab1b21d9",
          "tab": "ask",
          "content": "<div class=\"markdown-text\"><p>问一下  npm stop 会关了全部端口 加了title 也不管用那</p>\n</div>",
          "title": "node egg npm stop",
          "last_reply_at": "2018-04-04T03:00:06.895Z",
          "good": false,
          "top": false,
          "reply_count": 1,
          "visit_count": 8,
          "create_at": "2018-04-04T02:59:24.973Z",
          "author": {
              "loginname": "zhangchenna",
              "avatar_url": "https://avatars0.githubusercontent.com/u/8108749?v=4&s=120"
          }
      },
      {
          "id": "5ac0c2c65b8d68f72c147466",
          "author_id": "54054f7c0256839f714716ea",
          "tab": "share",
          "content": "<div class=\"markdown-text\"><p>北京时间 3 月 31 日举行的 2018 TensorFlow 开发者峰会上，TensorFlow 宣布重大更新：增加支持 JavaScript，并推出开源库 TensorFlow.js，用户可以完全在浏览器定义、训练和运行机器学习模型。谷歌大脑负责人 Jeff Dean、TensorFlow 总监 Rajat Monga 等人进行了 Keynote 演讲。</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/35150850\">https://zhuanlan.zhihu.com/p/35150850</a></p>\n</div>",
          "title": "又有好玩的了，TensorFlow.js发布",
          "last_reply_at": "2018-04-04T02:59:44.746Z",
          "good": false,
          "top": false,
          "reply_count": 5,
          "visit_count": 671,
          "create_at": "2018-04-01T11:30:14.482Z",
          "author": {
              "loginname": "yuu2lee4",
              "avatar_url": "https://avatars1.githubusercontent.com/u/8046366?v=4&s=120"
          }
      },
      {
          "id": "5ac365fee34737560fcca9d0",
          "author_id": "515005e9604b3d512109bb17",
          "tab": "share",
          "content": "<div class=\"markdown-text\"><blockquote>\n<p>原文链接：<a href=\"https://xcoder.in/2018/04/01/random-connected-area/\">https://xcoder.in/2018/04/01/random-connected-area/</a></p>\n</blockquote>\n<p>最近在知乎上看到一个问题，「<a href=\"https://www.zhihu.com/question/269483551/answer/354477009\">随机生成指定面积单连通区域？</a>」，感觉还挺有意思的，于是整理一下写一篇新文章。</p>\n<h2>问题阐述</h2>\n<p>如下图所示，在 10x10 的区域中，随机生成面积为 6 的单连通区域，该「随机」包括「位置随机」以及「形状随机」。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b28e68f456dd?w=2888&amp;h=3124&amp;f=jpeg&amp;s=1944536\" alt=\"示意图\"></p>\n<p>注意：</p>\n<ol>\n<li>单连通区域定义是该区域每一个区块上下左右至少连着另一个区块；</li>\n<li>采用周期性结构，超出右边移到最左边，以此类推。</li>\n</ol>\n<blockquote>\n<p>其中点 2 可以分采用和不采用周期性结构分别讨论。</p>\n</blockquote>\n<h2>随便说说</h2>\n<p>这个问题，我不知道原题提问者想要做什么事。但是就这题本身而言，我们可以拿它去生成一个随机地图，例如：</p>\n<blockquote>\n<p>建造、等待的沙盒类手游，游戏中有一个空岛，玩家能在上面建造自己的建筑然后等待各种事件完成。<strong>空岛形状随机生成，并且都联通且面积一定，这样每个玩家进去的时候就能得到不同地形</strong>。</p>\n</blockquote>\n<h2>解决一下</h2>\n<p>在得知了问题原题之后，我们就可以照着题目的意思开始解决了。</p>\n<h3>DFS</h3>\n<p>其实这么一个问题一出现，脑子里面就瞬间涌出几个词汇：<a href=\"https://en.wikipedia.org/wiki/Depth-first_search\">DFS</a>、<a href=\"https://en.wikipedia.org/wiki/Flood_fill\">Flood fill</a>、<a href=\"https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86\">并查集</a>等等。</p>\n<p>那么其实这最粗暴的办法相当于你假想有一个连通区域，然后你去 Flood fill 它——至于墙在哪，在递归的每一个节点的时候<strong>随机一下搜索方向的顺序就可以了</strong>。</p>\n<h4>实现外壳</h4>\n<p>我们先实现一个类的框架吧（我是 Node.js 开发者，自然用 JavaScript 进行 Demo 的输出）。</p>\n<pre class=\"prettyprint language-javascript\"><code>const INIT = Symbol(&quot;init&quot;);\n\nclass Filler {\n    &#x2F;**\n     * Filler 构造函数\n     * @constructor\n     * @param {Number} length 地图总宽高\n     * @param {Number} needArea 需要填充的区域面积\n     *&#x2F;\n    constructor(length, needArea) {\n        this.length = length;\n        this.needArea = needArea;\n    }\n\n    &#x2F;**\n     * 初始化地图\n     *&#x2F;\n    [INIT]() {\n        &#x2F;**\n         * 为了方便，地图就用一个二维字符数组表示\n         *\n         *   + . 代表空地\n         *   + x 代表填充\n         *&#x2F;\n        this.map = [];\n        this.count = 0;\n        for(let i = 0; i &lt; this.length; i++) {\n            let row = [];\n            for (let j = 0; j &lt; this.length; j++) row.push(&quot;.&quot;);\n            this.map.push(row);\n        }\n     }\n\n     &#x2F;**\n      * 填充递归函数\n      * @param {Number} x 坐标 X 轴的值\n      * @param {Number} y 坐标 Y 轴的值\n      * @return 填充好的地图二维数组\n      *&#x2F;\n     fill(x, y) {\n        &#x2F;&#x2F; 待实现\n     }\n}\n</code></pre><h4>非周期性实现</h4>\n<p>有了架子之后，我们就可以实现递归函数 <code>fill</code> 了，整理一下流程如下：</p>\n<ol>\n<li>随机一个起点位置，并以此开始递归搜索；</li>\n<li><code>fill(x, y)</code> 进入递归搜索：\n<ol>\n<li>如果需要初始化地图就调用 <code>this[INIT]()</code>；</li>\n<li><code>this.count++</code>，表示填充区域面积加了 <code>1</code>，并在数组中将该位置填充为 <code>x</code>；</li>\n<li><code>this.count</code> 是否等于所需要的面积：\n<ol>\n<li>若等于，则返回当前的地图状态；</li>\n<li>若不等于，则继续 2.4；</li>\n</ol>\n</li>\n<li>随机四个方向的顺序；</li>\n<li>对四个方向进行循环：\n<ol>\n<li><code>x</code>、<code>y</code> 轴的值按当前方向走一个算出新的坐标值 <code>newX</code> 和 <code>newY</code>；</li>\n<li>判断坐标是否合法（越界算非法）：\n<ol>\n<li>若非法则回 2.5 继续下一个方向；</li>\n<li>若合法则继续 2.5.3；</li>\n</ol>\n</li>\n<li>递归 <code>fill(newX, newY)</code> 得到结果，若有结果则返回；</li>\n</ol>\n</li>\n<li>若循环完四个方向都还没返回结果则会跳到这一步来，这个时候进行状态还原，递归跳回上一层进行下一个状态的搜索。</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>在这里「状态还原」表示把 <code>this.count--</code> 还原回当前坐标填充前的状态，并且把当前填充的 <code>'x'</code> 给还原回 <code>'.'</code>。</p>\n</blockquote>\n<p>照着上面的流程很快就能得出代码结论：</p>\n<pre class=\"prettyprint language-javascript\"><code>const _ = require(&quot;lodash&quot;);\n\nclass Filler {\n    ...\n\n    fill(x, y) {\n        &#x2F;&#x2F; 初始化地图\n        const needInit = !arguments[2];\n        if(needInit) this[INIT]();\n\n        &#x2F;&#x2F; 如果当前坐标已被填充，则返回空\n        if(this.map[x][y] === &quot;x&quot;) return;\n\n        &#x2F;&#x2F; 填充当前坐标\n        this.count++;\n        this.map[x][y] = &quot;x&quot;;\n\n        &#x2F;&#x2F; 填充满了则返回当前地图\n        if(this.count === this.needArea) return Object.assign([], this.map);\n\n        &#x2F;&#x2F; 随机四个方向的顺序\n        const dirs = _.shuffle([ [ 0, 1 ], [ 0, -1 ], [ 1, 0 ], [ -1, 0 ] ]);\n\n        &#x2F;&#x2F; 循环四个方向\n        for(let i = 0; i &lt; 4; i++) {\n            const dir = dirs[i];\n            let newX = x + dir[0];\n            let newY = y + dir[1];\n\n            &#x2F;&#x2F; 判断边界\n            {\n                if(newX &lt; 0 || newX &gt;= this.length || newY &lt; 0 || newY &gt;= this.length) continue;\n            }\n\n            &#x2F;&#x2F; 进入下一层递归并得到结果\n            const ret = this.fill(newX, newY, true);\n\n            &#x2F;&#x2F; 若结果非空则返回结果\n            if(ret) return ret;\n        }\n\n        &#x2F;&#x2F; 状态还原\n        this.count--;\n        this.map[x][y] = &quot;.&quot;;\n    }\n}\n</code></pre><p>这么一来，类就写好了。接下去我们只要实现一些交互的代码，就可以看效果了。</p>\n<blockquote>\n<p><a href=\"https://jsfiddle.net/XadillaX/x2ur8kvj/\">点我</a>进入 JSFiddle 看效果。</p>\n</blockquote>\n<p>如果懒得进入 JSFiddle 看，也可以看看下面的几个截图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b28e6902d5f6?w=160&amp;h=160&amp;f=png&amp;s=3438\" alt></p>\n<p>10x10 填 50 效果图</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b28e691d2a8d?w=160&amp;h=160&amp;f=png&amp;s=2803\" alt></p>\n<p>10x10 填 6 效果图</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b28e68ea0481?w=800&amp;h=800&amp;f=png&amp;s=51944\" alt></p>\n<p>50x50 填 50 效果图</p>\n<h4>周期性实现</h4>\n<p>其实原题说了一个条件，那就是<strong>采用周期性结构，超出右边移到最左边，以此类推</strong>。</p>\n<p>而我们前文的代码其实是照着非周期性结构来实现的。不过如果我们要将其改成周期性实现也很简单，只需要把前文代码中边界判断的那一句代码改为周期性计算的代码即可，也就是说要把这段代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 判断边界\n{\n    if(newX &lt; 0 || newX &gt;= this.length || newY &lt; 0 || newY &gt;= this.length) continue;\n}\n</code></pre><p>改为：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 周期性计算\n{\n    if(newX &lt; 0) newX = this.length - 1;\n    if(newX &gt;= this.length) newX = 0;\n    if(newY &lt; 0) newY = this.length - 1;\n    if(newY &gt;= this.length) newY = 0;\n}\n</code></pre><p>这个时候出来的效果就是这样的了：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b295d10ecf1d?w=160&amp;h=160&amp;f=png&amp;s=3789\" alt></p>\n<p>10x10 填 50 周期性效果图</p>\n<h4>抛弃状态还原</h4>\n<p>至此为止 DFS 的代码基本上完成了。不过目前来说，当然这个算法的一个缺陷就是，当需要面积与总面积比例比较大的时候，有可能陷入搜索的死循环（或者说效率特别低），因为要不断复盘。</p>\n<p>所以我们可以做点改造——由于我们不是真的为了搜索到某个状态，而只是为了填充我们的小点点，那么 DFS 中比较经典的「状态还原」就不需要了，也就是说：</p>\n<pre class=\"prettyprint language-javascript\"><code>this.count--;\nthis.mat[x][y] = &quot;.&quot;;\n</code></pre><p>这两行代码可以删掉了，用删掉上面两行代码的代码跑一下，我用 50x50 填充 800 格子的效果：</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2997f695944?w=800&amp;h=800&amp;f=png&amp;s=66548\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b29b12ce548d?w=800&amp;h=800&amp;f=png&amp;s=65629\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b29b129588f3?w=800&amp;h=800&amp;f=png&amp;s=63327\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b29b12d9ce57?w=800&amp;h=800&amp;f=png&amp;s=69442\" alt></th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<p>继续之前的 50x50 填充 50：</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b29b12cd09cd?w=800&amp;h=800&amp;f=png&amp;s=51953\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b29cb4c961c7?w=800&amp;h=800&amp;f=png&amp;s=51448\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b29cb4f9c004?w=800&amp;h=800&amp;f=png&amp;s=51569\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b29cb4f6b9c5?w=800&amp;h=800&amp;f=png&amp;s=50903\" alt></th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<h3>生成「胖胖的」区域</h3>\n<p>上面 DFS 的方法，由于每次都要走完一条路，虽然会转弯导致黏连，但在填充区域很小的情况下，很容易生成“瘦瘦的区域”。</p>\n<p>这里再给出另一个方法，一个 <code>for</code> 搞定的，思路如下：</p>\n<ol>\n<li>先随机一个起始点，并将该点加入边界池；</li>\n<li>循环 N - 1 次（N 为所需要填充的面积）：\n<ol>\n<li>从边界池中随机取出一个边界；</li>\n<li>算出与其接壤的四个点，取出还未被填充的点；</li>\n<li>在取出的点中随机一个将其填充；</li>\n<li>填充后计算改点接壤的四个点是否有全都是已经填充了的，若不是，则将该坐标加入边界池；</li>\n<li>拿着刚才计算的接壤的四个点，分别判断其是否周边四个点都已被填充，若是且该点在边界池中，则从边界池拿走；</li>\n<li>回到第二大步继续循环；</li>\n</ol>\n</li>\n<li>返回填充好的结果。</li>\n</ol>\n<p>给出代码 Demo：</p>\n<pre class=\"prettyprint language-javascript\"><code>function random(max) {\n    return Math.round(Math.random() * max);\n}\n\nclass Filler2 {\n    constructor(length, needArea) {\n        this.length = length;\n        this.needArea = needArea;\n    }\n\n    _getContiguous(frontier) {\n        return Filler2.DIRS.map(dir =&gt; ({\n            x: frontier.x + dir[0],\n            y: frontier.y + dir[1]\n        }));\n    }\n\n    fill() {\n        const mat = [];\n        for (let i = 0; i &lt; this.length; i++) {\n            let row = [];\n            for (let j = 0; j &lt; this.length; j++) row.push(&quot;.&quot;);\n            mat.push(row);\n        }\n\n        const start = {\n            x: random(this.length - 1),\n            y: random(this.length - 1)\n        };\n        mat[start.x][start.y] = &quot;x&quot;;\n\n        let frontierCount = 1;\n        const frontiers = {\n            [&#96;${start.x}:${start.y}&#96;]: true\n        };\n\n        for (let i = 1; i &lt; this.needArea; i++) {\n            &#x2F;&#x2F; 取出一个边界\n            const randIdx = random(frontierCount - 1);\n            const frontier = Object.keys(frontiers)[randIdx].split(&quot;:&quot;).map(n =&gt; parseInt(n));\n\n            &#x2F;&#x2F; _getContiguous 算出接壤坐标，filter 去除无用坐标\n            const newCoors = this._getContiguous({\n                x: frontier[0],\n                y: frontier[1]\n            }).filter(coor =&gt; {\n                if (coor.x &lt; 0 || coor.y &lt; 0 || coor.x &gt;= this.length || coor.y &gt;= this.length) return false;\n                if (mat[coor.x][coor.y] === &quot;x&quot;) return false;\n                return true;\n            });\n\n            &#x2F;&#x2F; 随机取一个坐标\n            const newCoor = newCoors[random(0, newCoors.length - 1)];\n\n            &#x2F;&#x2F; 填充进去\n            mat[newCoor.x][newCoor.y] = &quot;x&quot;;\n\n            &#x2F;&#x2F; 获取接壤坐标\n            const contiguousOfNewCoor = this._getContiguous(newCoor).filter(coor =&gt; {\n                if (coor.x &lt; 0 || coor.y &lt; 0 || coor.x &gt;= this.length || coor.y &gt;= this.length) return false;\n                return true;\n            });\n\n            &#x2F;&#x2F; 若有一个接壤点为空，就认为当前坐标是边界，若是边界则把当前坐标加入对象\n            if (contiguousOfNewCoor.reduce((ret, coor) =&gt; {\n                    if (mat[coor.x][coor.y] === &quot;x&quot;) return ret;\n                    return true;\n                }, false)) {\n                frontiers[&#96;${newCoor.x}:${newCoor.y}&#96;] = true;\n                frontierCount++;\n            }\n\n            &#x2F;&#x2F; 再检查接壤的坐标是否继续为边界\n            for (let i = 0; i &lt; contiguousOfNewCoor.length; i++) {\n                const cur = contiguousOfNewCoor[i];\n\n                const isFrontier = this._getContiguous(cur).filter(coor =&gt; {\n                    if (coor.x &lt; 0 || coor.y &lt; 0 || coor.x &gt;= this.length || coor.y &gt;= this.length) return false;\n                    return true;\n                }).reduce((ret, coor) =&gt; {\n                    if (mat[coor.x][coor.y] === &quot;x&quot;) return ret;\n                    return true;\n                }, false);\n\n                &#x2F;&#x2F; 若不是边界的话，只管删除\n                if (!isFrontier &amp;&amp; frontiers[&#96;${cur.x}:${cur.y}&#96;]) {\n                    delete frontiers[&#96;${cur.x}:${cur.y}&#96;];\n                    frontierCount--;\n                }\n            }\n        }\n\n        &#x2F;&#x2F; 一圈下来，就出结果了\n        return mat;\n    }\n}\n\nFiller2.DIRS = [ [ 0, 1 ], [ 0, -1 ], [ 1, 0 ], [ -1, 0 ] ];\n</code></pre><blockquote>\n<p><strong>注意</strong>：上面的代码是我一溜烟写出来的，所以并没有后续优化代码简洁度，其实很多地方的代码可以抽象并复用的，懒得改了，能看就好了。用的时候就跟之前 DFS 代码一样 <code>new</code> 一个 <code>Filler2</code> 出来并 <code>fill</code> 就好了。</p>\n<p>效果依然可以去 <a href=\"https://jsfiddle.net/XadillaX/36f6obca/\">JSFiddle</a> 看。</p>\n</blockquote>\n<p>或者也可以直接看效果图：</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b29f5be77955?w=800&amp;h=800&amp;f=png&amp;s=48779\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2a0ea61abd7?w=800&amp;h=800&amp;f=png&amp;s=42388\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2a0ea23e1af?w=800&amp;h=800&amp;f=png&amp;s=48754\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2a0ea8aac7d?w=800&amp;h=800&amp;f=png&amp;s=52737\" alt></th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<p>50x50 填充 800 胖胖的区域</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2a0ea7c46f2?w=800&amp;h=800&amp;f=png&amp;s=48906\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2a24cc55273?w=800&amp;h=800&amp;f=png&amp;s=49471\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2a24ce98fc8?w=800&amp;h=800&amp;f=png&amp;s=49916\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2a24cee8841?w=800&amp;h=800&amp;f=png&amp;s=48729\" alt></th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<p>50x50 填充 50 胖胖的区域</p>\n<p>显而易见，跟之前 DFS 生成出来的奇形怪状相比，这种算法生成的连通区域更像是一块 Mainland，而前者则更像是一个洼地沼泽或者丛林。</p>\n<h3>结合一下？</h3>\n<p>前面两种算法，一个是生成瘦瘦的稀奇古怪的面积，一个是生成胖胖的区域。有没有办法说在生成胖胖的区域的情况下允许一定的稀奇古怪的形状呢？</p>\n<p>其实将两种算法结合一下就好了。结合的做法有很多，这里举一个例子，大家可以自己再去想一些出来。</p>\n<ol>\n<li>首先将需要的区域对半分（即配比 1 : 1），例如如果需要 800，就分为 400 跟 400。（为了长得好看，其实这个比例可以自行调配）</li>\n<li>将前一半的区域用 <code>for</code> 生成胖胖的区域；</li>\n<li>将剩下的区域随机几次，每次随机一个剩下所需要的面积以内的数，将这个数字作为 DFS 所需要生成的面积量，并从边界数组中随机取一个边界坐标并计算其合法接壤坐标开始进行 DFS 得到结果；</li>\n<li>循环第 3 步知道所需区域面积符合要求为止。</li>\n</ol>\n<blockquote>\n<p><strong>注意</strong>：为了保证每次 DFS 一开始的时候都能取到最新的边界坐标，在 DFS 流程中的时候每标一个区域填充也必须走一遍边界坐标更新的逻辑。</p>\n</blockquote>\n<p>具体代码就不放文章里面解析了，大家也可以到 <a href=\"https://jsfiddle.net/XadillaX/0bnzpw8d/\">JSFiddle</a> 中去观看。</p>\n<p>或者也可以直接看效果图：</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2a7100746d3?w=800&amp;h=800&amp;f=png&amp;s=56770\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2a7ec2ed84a?w=800&amp;h=800&amp;f=png&amp;s=55096\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2a7ec33e5b0?w=800&amp;h=800&amp;f=png&amp;s=55297\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2a951a3516d?w=800&amp;h=800&amp;f=png&amp;s=56183\" alt></th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<p>50x50 填充 800 混合区域（配比 3 : 1）</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2a951bb551c?w=800&amp;h=800&amp;f=png&amp;s=50196\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2a951d57f97?w=800&amp;h=800&amp;f=png&amp;s=49264\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2a951ce5c29?w=800&amp;h=800&amp;f=png&amp;s=49683\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2ab8f0eab9d?w=800&amp;h=800&amp;f=png&amp;s=49263\" alt></th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<p>50x50 填充 50 胖胖的区域（配比 4 : 1）</p>\n<h3>还能更丧心病狂吗？</h3>\n<p>结合了两种算法，我们得到了一个我认为可能会更好看一点的区域。</p>\n<p>此外，我们还能继续「丧心病狂」一点，例如两种方式交替出现，流程如下：</p>\n<ol>\n<li>指定特定方法和面积，奇数次用 <code>for</code>，偶数次用 DFS；\n<ol>\n<li>如果是 <code>for</code> 则随机一个 <code>Math.min(剩余面积, 总面积 / 4)</code> 的数字；</li>\n<li>如果是 DFS 则随机一个 <code>Math.min(剩余面积, 总面积 / 10)</code> 的数字；</li>\n</ol>\n</li>\n<li>从边界数组中取一个坐标，并从合法接壤坐标中取一个坐标出来；</li>\n<li>以第 2 步取出的坐标为起点，使用第 1 步指定的方法生成第 1 步指定的面积的单连通区域；</li>\n<li>如果生成面积仍小于指定面积，则回到第 1 步继续循环，否则返回当前结果。</li>\n</ol>\n<p>依旧是给出 <a href=\"https://jsfiddle.net/XadillaX/5rx7vdzL/\">JSFiddle 的预览</a>。</p>\n<p>或者也可以直接看效果图：</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2ab8f170b0e?w=800&amp;h=800&amp;f=png&amp;s=52295\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2acb2a2d596?w=800&amp;h=800&amp;f=png&amp;s=57657\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2acb292ea3f?w=800&amp;h=800&amp;f=png&amp;s=56413\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2ad7d2cce51?w=800&amp;h=800&amp;f=png&amp;s=59807\" alt></th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<p>50x50 填充 800 丧病区域</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2ad7d6ba38c?w=800&amp;h=800&amp;f=png&amp;s=49868\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2ae0b22e982?w=800&amp;h=800&amp;f=png&amp;s=49075\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2ae94ae2d30?w=800&amp;h=800&amp;f=png&amp;s=48648\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2af25a8f488?w=800&amp;h=800&amp;f=png&amp;s=49390\" alt></th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<p>50x50 填充 800 丧病区域</p>\n<blockquote>\n<p><strong>注意</strong>：这里只给出思路，具体配比和详细流程大家可以继续优化。</p>\n</blockquote>\n<h2>几张效果对比图</h2>\n<p>最后，这里给出几张 10x10 填 50 的效果图放一起对比一下。</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2b2073c1c95?w=160&amp;h=160&amp;f=png&amp;s=3294\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2b282c78c28?w=160&amp;h=160&amp;f=png&amp;s=3857\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2b31edb5ba6?w=160&amp;h=160&amp;f=png&amp;s=2838\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2b38c4c0f10?w=160&amp;h=160&amp;f=png&amp;s=3959\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2b41420d207?w=160&amp;h=160&amp;f=png&amp;s=3377\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2b4d892c420?w=160&amp;h=160&amp;f=png&amp;s=3149\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2b4d8a55ec5?w=160&amp;h=160&amp;f=png&amp;s=3617\" alt></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DFS</td>\n<td>周期性 DFS</td>\n<td>非还原 DFS</td>\n<td>非还原周期性 DFS</td>\n<td>胖胖的</td>\n<td>结合</td>\n<td>更丧病</td>\n</tr>\n</tbody>\n</table>\n<p>以及，几张 50x50 填充 800 面积的效果图对比。</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2b69feea003?w=800&amp;h=800&amp;f=png&amp;s=6103\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2b69feea003?w=800&amp;h=800&amp;f=png&amp;s=6103\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2b817ba1757?w=800&amp;h=800&amp;f=png&amp;s=65764\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2b78efe087e?w=800&amp;h=800&amp;f=png&amp;s=68132\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2b92f819f4e?w=800&amp;h=800&amp;f=png&amp;s=50332\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2ba5473d193?w=800&amp;h=800&amp;f=png&amp;s=57563\" alt></th>\n<th><img src=\"https://user-gold-cdn.xitu.io/2018/4/3/1628b2b9b6e873c4?w=800&amp;h=800&amp;f=png&amp;s=56472\" alt></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DFS</td>\n<td>周期性 DFS</td>\n<td>非还原 DFS</td>\n<td>非还原周期性 DFS</td>\n<td>胖胖的</td>\n<td>结合</td>\n<td>更丧病</td>\n</tr>\n</tbody>\n</table>\n<h2>小结</h2>\n<p>本文主要还是讲了，如何随机生成一个指定面积的单连通区域。从一开始拍脑袋就能想到 DFS 开始，延伸到胖胖的区域，然后从个人认为「图不好看」开始，想办法如何结合一下两种算法使其变得更自然。</p>\n<p>针对同一件事的算法们并非一成不变或者不可结合的。不是说该 DFS 就只能 DFS，该 <code>for</code> 就只能 <code>for</code>，稍微结合一下也许食用效果更佳哦。</p>\n<p>哦对了，在这之前还有一个例子就是我在三年多前写的主题色提取的文章《<a href=\"https://xcoder.in/2014/09/17/theme-color-extract/#%E6%88%91%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84\">图片主题色提取算法小结</a>》，其中就讲到我最后的方法就是结合了八叉树算法和最小差值法，使其在提取比较贴近的颜色同时又能够规范化提取出来的颜色。</p>\n<p>总之就是多想想，与诸君共勉。</p>\n</div>",
          "title": "随机生成指定面积单连通区域",
          "last_reply_at": "2018-04-04T02:54:53.893Z",
          "good": true,
          "top": false,
          "reply_count": 3,
          "visit_count": 190,
          "create_at": "2018-04-03T11:31:10.630Z",
          "author": {
              "loginname": "xadillax",
              "avatar_url": "https://avatars3.githubusercontent.com/u/2842176?v=4&s=120"
          }
      },
      {
          "id": "5ac432d837f5d1510f57c896",
          "author_id": "59a4d33fd97b7e2308242831",
          "tab": "ask",
          "content": "<div class=\"markdown-text\"><p>比如我使用pm2 部署2个 ws进程， 这样如果有1000个人连接的话，会有一部分人连接到进程A，剩下的人连接到进程B，实际上进入了2个房间，有没有方法能够 解决这个问题，比如一个请求过来，指定路由到进程A ，pm2应该是有负载分发机制，不知道是否支持指定进程处理</p>\n</div>",
          "title": "websocket 使用pm2的  cluster模式",
          "last_reply_at": "2018-04-04T02:23:41.574Z",
          "good": false,
          "top": false,
          "reply_count": 1,
          "visit_count": 49,
          "create_at": "2018-04-04T02:05:12.397Z",
          "author": {
              "loginname": "312xiaoguai",
              "avatar_url": "https://avatars0.githubusercontent.com/u/17775548?v=4&s=120"
          }
      },
      {
          "id": "5ac42c770ab0448f0fe3f854",
          "author_id": "5ac42b430ab0448f0fe3f853",
          "tab": "ask",
          "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/Fs9wzktNF1J2F0yszQz8LKB66oQo\" alt=\"微信截图_20180404093707.png\"></p>\n<blockquote></blockquote>\n<p>$ istanbul cover ./node_modules/mocha/bin/_mocha ./tests/fibonacci/main.test.js\nfibonacci test\n√ should equal 0 when n === 0\n√ should receive a error\n√ should receive a error 1\n√ n cant big than 40\n√ n cant less than 0\n5 passing (16ms)\nNo coverage information was collected, exit without writing coverage information</p>\n</div>",
          "title": "请问[nodejs包教不包会]第六课,测试没有覆盖率信息是什么情况?是需要写配置文件吗?",
          "last_reply_at": "2018-04-04T01:37:59.298Z",
          "good": false,
          "top": false,
          "reply_count": 0,
          "visit_count": 42,
          "create_at": "2018-04-04T01:37:59.298Z",
          "author": {
              "loginname": "hhniao",
              "avatar_url": "https://avatars3.githubusercontent.com/u/12420958?v=4&s=120"
          }
      },
      {
          "id": "5ac3480037f5d1510f57c87d",
          "author_id": "5826acd2d3abab717d8b4bd6",
          "tab": "ask",
          "content": "<div class=\"markdown-text\"><p>cnode 的 <code>/topic/:id</code> 接口有缓存，造成无论我点击了收藏还是取消收藏，但是读取的 <code>is_collect</code> 一直为 <code>false</code>。</p>\n</div>",
          "title": "cnode 的 `/topic/:id` 接口有缓存，造成无论我点击了收藏还是取消收藏，但是读取的 `is_collect` 一直为 `false`",
          "last_reply_at": "2018-04-04T01:31:09.091Z",
          "good": false,
          "top": false,
          "reply_count": 1,
          "visit_count": 142,
          "create_at": "2018-04-03T09:23:12.788Z",
          "author": {
              "loginname": "fengyun2",
              "avatar_url": "https://avatars0.githubusercontent.com/u/8147202?v=4&s=120"
          }
      },
      {
          "id": "59ee9bbe9cf198a85bd2e210",
          "author_id": "58a4614ec41c94fd36911faf",
          "tab": "ask",
          "content": "<div class=\"markdown-text\"><p>麻烦问一下怎么在node中用import 怎么利用babel和webpack搭建项目结构，能让写js直接就es6的，希望大神能推荐几篇文章或者github源码看看学习一下，谢谢了</p>\n</div>",
          "title": "如何在node中使用import",
          "last_reply_at": "2018-04-04T01:11:26.271Z",
          "good": false,
          "top": false,
          "reply_count": 13,
          "visit_count": 2837,
          "create_at": "2017-10-24T01:47:42.848Z",
          "author": {
              "loginname": "wocaatm",
              "avatar_url": "https://avatars2.githubusercontent.com/u/11764069?v=4&s=120"
          }
      },
      {
          "id": "5ac3c495e34737560fcca9db",
          "author_id": "584a834e4c17b38d3543651d",
          "tab": "ask",
          "content": "<div class=\"markdown-text\"><p>来自半夜的测试来自半夜的测试来自半夜的测试来自半夜的测试来自半夜的测试来自半夜的测试来自半夜的测试来自半夜的测试来自半夜的测试来自半夜的测试来自半夜的测试来自半夜的测试来自半夜的测试来自半夜的测试来自半夜的测试</p>\n</div>",
          "title": "来自半夜的测试",
          "last_reply_at": "2018-04-04T01:05:06.489Z",
          "good": false,
          "top": false,
          "reply_count": 2,
          "visit_count": 103,
          "create_at": "2018-04-03T18:14:45.575Z",
          "author": {
              "loginname": "beyondouyuan",
              "avatar_url": "https://avatars0.githubusercontent.com/u/11817318?v=4&s=120"
          }
      },
      {
          "id": "5ac3a177997649118299daf7",
          "author_id": "5aa88cdae7b166bb7b9eca1a",
          "tab": "ask",
          "content": "<div class=\"markdown-text\"><p><strong>传不了图片</strong>，这是什么编辑器谁知道介绍一下？</p>\n</div>",
          "title": "服务器走神了",
          "last_reply_at": "2018-04-04T00:59:19.946Z",
          "good": false,
          "top": false,
          "reply_count": 2,
          "visit_count": 143,
          "create_at": "2018-04-03T15:44:55.616Z",
          "author": {
              "loginname": "shileima",
              "avatar_url": "https://avatars2.githubusercontent.com/u/3283706?v=4&s=120"
          }
      },
      {
          "id": "5a9f951c7811af0f652221d4",
          "author_id": "58058ff1487e1e4578afb5c2",
          "tab": "ask",
          "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FuWQizGaUvsgO59c4xShHdWncMZR\" alt=\"1520407779152.jpg\"></p>\n<p>This can create some bad situations because it allows you to “starve” your I/O by making recursive process.nextTick() calls；如何理解这个“starve”,饥饿？</p>\n</div>",
          "title": "关于英文文档有一段话一直不是很理解，求帮助",
          "last_reply_at": "2018-04-03T23:52:37.352Z",
          "good": false,
          "top": false,
          "reply_count": 6,
          "visit_count": 289,
          "create_at": "2018-03-07T07:30:36.894Z",
          "author": {
              "loginname": "luanxuechao",
              "avatar_url": "https://avatars1.githubusercontent.com/u/13465762?v=4&s=120"
          }
      },
      {
          "id": "5ac375a196f344940fbbacf6",
          "author_id": "57e37080f7dea63b0e6ab90b",
          "tab": "ask",
          "content": "<div class=\"markdown-text\"><p>如上，已有域名，如何低成本批量注册邮箱，可能需要注册几千个或者上万个邮箱，邮箱只是用来接受确认信息</p>\n</div>",
          "title": "已有域名，如何低成本批量注册邮箱",
          "last_reply_at": "2018-04-03T19:26:58.062Z",
          "good": false,
          "top": false,
          "reply_count": 1,
          "visit_count": 139,
          "create_at": "2018-04-03T12:37:53.685Z",
          "author": {
              "loginname": "moonfy",
              "avatar_url": "https://avatars0.githubusercontent.com/u/20022453?v=4&s=120"
          }
      },
      {
          "id": "5abda4050b13e3ad6954cfb0",
          "author_id": "547c35030ae47dec03aa2939",
          "tab": "share",
          "content": "<div class=\"markdown-text\"><h4>第一节 简介</h4>\n<p>欢迎和我们一起来用以太坊开发构建一个去中心化电商DApp！我们将用区块链、星际文件系统（IPFS）、Node.js和MongoDB来构建电商平台类似淘宝的在线电商应用，卖家可以自由地出售商品，买家可以自由地购物：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/29/16271efc54d89429?w=657&amp;h=374&amp;f=png&amp;s=16405\" alt=\"ethereum dapp 以太坊DApp开发\"></p>\n<ol>\n<li>\n<p>去中心化： 和淘宝或<strong>eBay</strong>不同，我们把所有的商业逻辑和核心数据都放在以太坊区块链上，这使 得它成为一个完全去中心化的应用。和淘宝这样中心化的电商平台相比，一个去中心化的<strong>P2P</strong>电商应用显然有其独特的价值——至少你不用担心被平台封账户了。</p>\n</li>\n<li>\n<p>IPFS： 在以太坊上存储用于商品展示的图片和描述超文本十分昂贵，由于以太坊虚拟机的限制， 有时甚至是不可行的。为了解决这个问题，我们将会把商品图片和商品描述信息存储在同样去中心化的<strong>星际文件系统</strong>（<strong>IPFS</strong>)中，而仅仅在链上保存这些数据的<strong>ID</strong>。</p>\n</li>\n<li>\n<p>商品拍卖： 对于卖家而言，拍卖显然是一种非常好的提升商品利润空间的销售手段。因此我们在课程项目中将实现去中心化环境下的维科瑞（<strong>Vickery</strong>）拍卖 —— 这非常类似于<strong>eBay</strong>的自动竞价系统，而不是简单地对商品进行固定标价。</p>\n</li>\n<li>\n<p>资金托管： <strong>中心化</strong>的平台有一个优点在于它天然提供了买卖双方之间的信任中介。在<strong>去中心化</strong>的环境中，我们将使用一个多方托管合约来应对买卖双方可能的风险，<strong>托管合约</strong>采用<strong>投票机制</strong>来决定买家货款的最终流向。</p>\n</li>\n<li>\n<p>链下数据存储： 不要被去中心化限制我们的思维，传统的技术依然有其强大之处。我们将使用<strong>MongoDB</strong>在链下做一个同步的数据备份，以便实现单纯用区块链很难实现的功能：灵活的商品查询。</p>\n</li>\n</ol>\n<p>课程地址：<a href=\"http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6/?affid=cnodew\">http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6</a></p>\n<h4>第二节 去中心化，why？</h4>\n<p>在开始构建我们的应用之前，非常值得花一分钟时间，来理解为什么要在像以太坊这样的<strong>去中心化平台</strong>上搭建在线卖场。</p>\n<p><strong>eBay</strong>或<strong>淘宝</strong>这样的<strong>C2C电商平台</strong>已经获得了巨大成功，因为它使得买卖双方都相当便利：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/29/16271f5207737765?w=518&amp;h=135&amp;f=png&amp;s=6968\" alt=\"ebay-taobao 淘宝c2c电商平台\"></p>\n<p>在互联网成为主流之前，人们只能在小范围内、或者在邻里之间买卖商品。当越来越多的人使用互联网， 出现了像eBay这样的平台，无论来自世界的任何一个地方，你都可以在网上买卖商品。无论是商家还 是消费者，这样的平台都有其价值。</p>\n<p>尽管<strong>eBay</strong>这样的平台方便了大家，也改善了贸易和经济，但它也存在一些缺点：</p>\n<ol>\n<li>\n<p>被平台束缚。参与的商家受制于拥有平台的企业。在任何时候，平台拥有者可以自行决定在是否对某个商家进行封号处理，而如果商家严重依赖于平台，那么账号被封就是一个巨大的打击。</p>\n</li>\n<li>\n<p>商家费用高。商家上架商品要交费，售出商品也要交佣金。收费本身并没有错，毕竟eBay这样的平台提供了服务。但是，上架费有时太高了，这导致商家最后盈利很少，或是将成本转嫁到消费者身上。</p>\n</li>\n<li>\n<p>数据失控。商家或消费者都无法拥有本应属于自己的数据。评论、购买历史等等所有数据都为平台拥有者所有。比如，如果一个商家想要换一个提供商，或者想要导出商品评论或是其他数据都非常不容易，甚至不可能。</p>\n</li>\n</ol>\n<p>在<strong>以太坊</strong>上构建的去中心化电商平台就解决了这些问题：商家的账户不会被封；数据也是公开的，所以很容易导出数据；相对于中心化的平台，交易佣金也会低得多。</p>\n<h4>第三节  初步的功能特性</h4>\n<p>现在你应该已经理解了为什么要构建去中心化的电商应用，也了解了我们要构建的应用是什么，现在让我们来大致看一下，在这个项目中将要实现的主要功能特性：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/29/16271f6597481f51?w=704&amp;h=510&amp;f=png&amp;s=17521\" alt=\"ebay user case\"></p>\n<ol>\n<li>\n<p><strong>商品上架</strong>：应用应该支持卖家上架商品进行销售。我们将实现让任何人自由上架商品的功能。</p>\n</li>\n<li>\n<p><strong>商品浏览与搜索</strong>：应用应该支持买家方便地<strong>浏览商品列表</strong>。我们会实现浏览商品的功能，以及基于商品类别、拍卖时间等条件进行查询的功能。</p>\n</li>\n<li>\n<p><strong>商品拍卖</strong>：跟eBay一样，我们会实现<strong>维科瑞</strong>拍卖方式的商品竞价销售。由于<strong>以太坊</strong>上的一切交易都是公开的，因此我们的实现将会与中心化环境下有所不同。</p>\n</li>\n<li>\n<p><strong>资金托管</strong>：一旦出价结束，商品拍卖有了赢家以后，我们会创建由胜出的买方、卖方和任意第三方参与的托管合约，由<strong>托管合约</strong>来管理交易资金。</p>\n</li>\n<li>\n<p><strong>托管资金保护</strong>：为了保护托管资金，我们将采用<strong>多重签名</strong>（2/3）来实现防欺诈保护，即三个参与者有两个同意时，才会将托管资金释放给卖方，或是将托管资金返还给买方。</p>\n</li>\n</ol>\n<p>为了便于查询，我们会将商品数据同时存在链上和链下（数据库）；同时，为了避免图片等数据占用昂贵的链上存储，我们将把图片和商品描述信息上传到同样<strong>去中心化</strong>的<strong>IPFS</strong>网络。</p>\n<p>课程地址：<a href=\"http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6/?affid=cnodew\">http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6</a></p>\n<h4>第四节  基础知识要求</h4>\n<p>为了顺利地完成本课程的学习，你应该对以下语言/技术有一些了解：</p>\n<ol>\n<li><strong>Solidity/Truffle</strong>：课程将会深入使用<strong>solidity</strong>来编写合约。如果你还没有学过，建议你先学习一下<a href=\"http://xc.hubwiz.com/course/5a952991adb3847553d205d1/?affid=juejinw\"><strong>以太坊开发DApp入门教程</strong></a>，这样至少写过一两个简单的<strong>合约</strong>。同时，对<strong>truffle</strong>开发框架的基本了解也会十分有助于完成本课程。</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/29/16271f92e9ec2a92?w=500&amp;h=133&amp;f=png&amp;s=7933\" alt=\"solidity truffle\"></p>\n<ol>\n<li><strong>HTML/CSS/JavaScript</strong>：相比入门课程，本课程将会有更多的HTML和CSS代码。你应该对使用HTML/CSS构建前端有基本的了解。同时，我们将会进一步使用JavaScript。它会在服务端将数据保存到数据库，查询数据库并将结果返回给前端。<strong>web3.js</strong>用于前端与区块链的交互。为了适用各种背景的学习者，我们已经保持<strong>JavaScript</strong>代码尽可能地简单。</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/29/16271f9dabae75ff?w=620&amp;h=150&amp;f=png&amp;s=8063\" alt=\"html css js web3.js\"></p>\n<ol>\n<li><strong>Database</strong>：我们会用<strong>MongoDB</strong>在链下保存产品信息。无须特别了解MongoDB，但是基本的数据库知识有助于你顺利完成本课程的。</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/29/16271fb8fd610840?w=431&amp;h=117&amp;f=png&amp;s=4858\" alt=\"mongodb\"></p>\n<h4>第五节  系统架构</h4>\n<p>在开始着手具体的实现之前，先来看一下在本课程我们将要构建的<strong>去中心化电商DApp</strong>的<strong>架构</strong>。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/29/16271fc91d0f0c9f?w=582&amp;h=494&amp;f=png&amp;s=9395\" alt=\"ebay dapp architecture\"></p>\n<ol>\n<li>\n<p><strong>Web前端</strong>：web前端使用<strong>HTML/CSS/JavaScript</strong>开发，其中大量使用了<strong>web3js</strong>来访问区块链。用户将会通过这个前端应用来访问<strong>以太坊</strong>、<strong>IPFS</strong>和<strong>NodeJS</strong>服务器。</p>\n</li>\n<li>\n<p><strong>以太坊区块链</strong>：这是去中心化应用的核心，所有的代码（<strong>电商合约</strong>、<strong>资金托管合约</strong>）和交易都存储在链上，这包括所有的商品信息、买家的出价信息、商品竞价结果、资金流向投票结果等。</p>\n</li>\n<li>\n<p><strong>MongoDB</strong>：尽管核心数据存储在<strong>区块链</strong>上，但是为了方便买家对商品的检索和查询，例如只显示某一类的商品，或者显示即将过期的商品等等，我们会用MongoDB数据库来同步地存储和检索商品信息。</p>\n</li>\n<li>\n<p><strong>NodeJS服务器</strong>：这是<strong>后端</strong>服务器，我们会利用它给前端提供<strong>REST</strong>风格的<strong>API</strong>来查询商品， 同时，也利用它来响应对前端<strong>静态页面</strong>的请求。</p>\n</li>\n<li>\n<p><strong>IPFS</strong>: 当卖家上架一个商品时，前端会商品图片文件和介绍文本上传到<strong>IPFS</strong>，并将所上传文件的<strong>哈希值</strong>存到链上。</p>\n</li>\n</ol>\n<h4>第六节 理解架构的作用</h4>\n<p>为了帮助理解上一节谈到的那些组件的作用，让我们来看看一下卖家上架一个商品的流程：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/29/16271fe76b32a45c?w=590&amp;h=495&amp;f=png&amp;s=10875\" alt=\"ebay list item\"></p>\n<ul>\n<li>\n<p>(1)前端使用一个<strong>HTML表单</strong>来采集用户输入的商品细节，例如起拍价、商品图片、描述信息等。</p>\n</li>\n<li>\n<p>(2)(3) 前端将商品图片和介绍文本上传到<strong>IPFS</strong>，并返回所上传内容对应的链接（<strong>哈希</strong>）。</p>\n</li>\n<li>\n<p>(4)(5) 然后，<strong>web前端</strong>会调用电商合约将<strong>商品信息</strong>和<strong>IPFS</strong>链接存储到链上。当合约成功地将商品存入<strong>区块链</strong>后，就会触发一个<strong>事件</strong>，该事件中包含了商品所有的信息。</p>\n</li>\n<li>\n<p>(6)(7)(8) <strong>NodeJS</strong>服务器监听<strong>区块链事件</strong>，当事件被<strong>电商合约触发</strong>时，服务器读取事件内容并将商品信息插入到<strong>MongoDB</strong>数据库中。</p>\n</li>\n</ul>\n<p>当开始具体实现商品上架这一特性时，我们将重温这一流程。</p>\n<h4>第七节  敏捷开发</h4>\n<p>我们将采用<strong>敏捷开发</strong>的思想来实现去中心化电商<strong>DApp</strong>：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/29/16272000f473ee30?w=727&amp;h=604&amp;f=png&amp;s=38368\" alt=\"scrum way\"></p>\n<p>我们将全部的产品特性分别列入8个<strong>迭代</strong>周期，通过每一次的<strong>冲刺</strong>（<strong>sprint</strong>），我们都将得到一个可以发布的版本：</p>\n<p>前两个<strong>冲刺</strong>主要集中在使用<strong>solidity</strong>和<strong>truffle框架</strong>实现电商合约方面，这包括<strong>合约的设计、开发 、编译、部署与测试</strong>：</p>\n<ul>\n<li>\n<p>sprint-1：实现电商合约的商品上架和展示方法。</p>\n</li>\n<li>\n<p>sprint-2：实现电商合约的商品竞价和出价揭示方法。\n在电商合约基本实现之后，接下来的三个冲刺主要集中在前端用户界面的构建方面，这包括使用web3 与合约的交互，以及通过ipfs的开发接口上传图片等数据交互，当然，还有必不可少的DOM操作：</p>\n</li>\n<li>\n<p>sprint-3：为买家提供商品浏览界面。</p>\n</li>\n<li>\n<p>sprint-4：为卖家提供商品上架操作界面。</p>\n</li>\n<li>\n<p>sprint-5：为买家提供商品详情界面、竞价表单以及出价揭示表单。在接下来的两个冲刺里，我们将首先实现资金托管合约，用来管理竞价结束后胜出买家的资金；然后实现相应的用户操作界面。</p>\n</li>\n<li>\n<p>sprint-6：实现资金托管合约。</p>\n</li>\n<li>\n<p>sprint-7：基于资金托管合约，为参与托管各方提供操作界面。最后，为了便于商品的查询检索，我们将使用MongoDB来实现商品数据的链下存储。</p>\n</li>\n<li>\n<p>sprint-8：实现链下数据的同步与数据查询。</p>\n</li>\n</ul>\n<p>课程地址：<a href=\"http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6/?affid=cnodew\">http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6</a></p>\n</div>",
          "title": "以太坊开发DApp实战教程——用区块链、星际文件系统（IPFS）、Node.js和MongoDB来构建电商平台",
          "last_reply_at": "2018-04-03T15:00:02.418Z",
          "good": false,
          "top": false,
          "reply_count": 3,
          "visit_count": 468,
          "create_at": "2018-03-30T02:42:13.655Z",
          "author": {
              "loginname": "2596887568",
              "avatar_url": "https://avatars3.githubusercontent.com/u/9349200?v=4&s=120"
          }
      },
      {
          "id": "5a9e323b7811af0f65222147",
          "author_id": "55b6e3d9f30671210b35f945",
          "tab": "share",
          "content": "<div class=\"markdown-text\"><p><strong>v0.9.25发布</strong></p>\n<p>支持数学表达式和自动补全图片路径</p>\n<p><a href=\"https://github.com/marktext/marktext/releases/tag/v0.9.25\">https://github.com/marktext/marktext/releases/tag/v0.9.25</a></p>\n<p><strong>v0.7.17 发布</strong></p>\n<p>支持插入图片功能</p>\n<p><img src=\"https://i.loli.net/2018/03/20/5ab0e2b509424.gif\" alt></p>\n<p><strong>v0.6.14发布</strong></p>\n<p>支持 windows 和 linux 版本了。</p>\n<p><strong>Mark Text走上娱乐路线</strong></p>\n<p><a href=\"https://github.com/marktext/marktext\">https://github.com/marktext/marktext</a></p>\n<p>Mark Text 在0.6.12 版本支持全新斗图功能。</p>\n<p><img src=\"https://i.loli.net/2018/03/08/5aa155057dab8.jpg\" alt></p>\n<p>light 主题下界面是长这样的。\n<img src=\"//dn-cnode.qbox.me/FnOLtRot6wQGOi3CBw8sGd6Vuuk2\" alt=\"1520522630559.jpg\"></p>\n<p>Dark 主题下长这样。\n<img src=\"//dn-cnode.qbox.me/FvXxnm-xcdYVQkg1IpMFuKqkk_3h\" alt=\"1520522766406.jpg\"></p>\n<p>生成 markdown 图片格式，可以直接复制黏贴到 cnode及其他支持 markdown 的社区网站。</p>\n<p>从此妈妈再也不用担心我不会斗图了。</p>\n<p>— 分割线 —</p>\n<p><strong>废话不多说，直接上地址：</strong></p>\n<p>网站地址：<a href=\"//https://marktext.github.io/website/\">MarkText</a></p>\n<p>仓库地址：<a href=\"https://github.com/marktext/marktext\">MarkText</a></p>\n<h3>Mark Text</h3>\n<p><img src=\"//dn-cnode.qbox.me/FvWhG1Ke30sJZ7kUf9QzERBcSCDm\" alt=\"summary.jpg\"></p>\n<p>一款致力于提升用户写作体验的 Markdown 编辑器，其界面简洁，使用 snabbdom 作为其渲染引擎，保证了写作的流畅性。同时Mark Text 提供多种编辑模式。</p>\n<h4>源码模式</h4>\n<p><img src=\"//dn-cnode.qbox.me/FrTE1VR_TG8EEZg_cdRUf9PNXDRE\" alt=\"source-code-mode.jpg\"></p>\n<h4>Focus 模式</h4>\n<p><img src=\"//dn-cnode.qbox.me/Fjv7v-C6B7awFwd8b908zfmOvIa3\" alt=\"focus-mode.jpg\"></p>\n<p>欢迎大家使用，拍砖。</p>\n</div>",
          "title": "一款关注写作体验的 markdown 编辑器",
          "last_reply_at": "2018-04-03T14:50:24.181Z",
          "good": false,
          "top": false,
          "reply_count": 27,
          "visit_count": 2216,
          "create_at": "2018-03-06T06:16:27.079Z",
          "author": {
              "loginname": "Jocs",
              "avatar_url": "https://avatars0.githubusercontent.com/u/9712830?v=4&s=120"
          }
      },
      {
          "id": "5ac2c040e34737560fcca9a1",
          "author_id": "5a157ea76190c8912ebaccb9",
          "tab": "ask",
          "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/Fkt35KxVI3fNLnsOOlp5OP3Dnciz\" alt=\"微信截图_20180403074130.png\">\n为什么我的没有效果？百度到答案，也并没有解决</p>\n</div>",
          "title": "关于在Chrome浏览器输入js代码，在页面显示效果的问答",
          "last_reply_at": "2018-04-03T13:23:49.847Z",
          "good": false,
          "top": false,
          "reply_count": 1,
          "visit_count": 234,
          "create_at": "2018-04-02T23:44:00.250Z",
          "author": {
              "loginname": "JiaoZheng",
              "avatar_url": "https://avatars0.githubusercontent.com/u/24946849?v=4&s=120"
          }
      },
      {
          "id": "5ac31c870ab0448f0fe3f834",
          "author_id": "5ac31ac70ab0448f0fe3f833",
          "tab": "ask",
          "content": "<div class=\"markdown-text\"><p>比如where条件\nid &gt; 2 and state = 1\n标准写法</p>\n<pre class=\"prettyprint\"><code>where: {id: {$gt: 2}, state: 1}\n</code></pre><p>或者</p>\n<pre class=\"prettyprint\"><code>where: {\n      $and: [\n        {id: {$gt: 2}},\n        {state: 1}\n      ]}\n</code></pre><p>但是有没有方法，直接写成id &gt; 2 and state = 1\n类似这样：where: {‘id &gt; 2 and state = 1’}\n直接这样写报错，官方文档也没找到，只有sequelize.query函数，不过这样太底层了。</p>\n</div>",
          "title": "Sequelize 中的where怎么写原生sql查询？",
          "last_reply_at": "2018-04-03T09:51:12.351Z",
          "good": false,
          "top": false,
          "reply_count": 2,
          "visit_count": 193,
          "create_at": "2018-04-03T06:17:43.409Z",
          "author": {
              "loginname": "sjn1978",
              "avatar_url": "https://avatars2.githubusercontent.com/u/7509082?v=4&s=120"
          }
      },
      {
          "id": "5ac2085c0ab0448f0fe3f7f0",
          "author_id": "596a2b5edb0b6aec18a28569",
          "tab": "share",
          "content": "<div class=\"markdown-text\"><h4><strong>起因</strong></h4>\n<p>最近在Cnode社区看到社区大佬们重构代码用了新的技术栈，现正在公测阶段。因为正好擅长用Node.JS来开发自动化测试。为了对社区做点贡献，拉了几个技术好友，计划利用周末时间帮社区写些UI自动化代码。这一建议得到了CNodeJS的狼叔的大力支持，这一建议的帖子置顶后，又有好多热心的朋友加入了进来，有擅长自动化开发的、也有擅长手动测试的同学。</p>\n<h4><strong>计划</strong></h4>\n<ul>\n<li><strong>时间</strong>：准备星期日(03-25)用一天时间进行。</li>\n<li><strong>地点</strong>：四川北路乍浦路的一间创业工坊</li>\n<li><strong>目标</strong>：基于Node.js开发CNode社区的UI自动化测试代码。</li>\n<li><strong>使用技术</strong>：当然要用Node.JS. 主要用Nodejs + <a href=\"https://github.com/cucumber/cucumber-js\">Cucumber</a> + Selenium</li>\n<li><strong>开发环境</strong>：Windows 系统使用 <a href=\"http://cuketest.com/\">CukeTest</a> 进行开发。Mac 系统使用 VSCode 进行开发</li>\n</ul>\n<p>迫不急待的小朋友可以先来看一下成果，经过一整天的努力，CNodeJS的各项主要界面测试都实现了，不光有代码，而且有自然语言描述的测试用例，确保所有人都能看得懂：\n<img src=\"//dn-cnode.qbox.me/Ft8epShi4qfNLoes7jAe9nfYK20q\" alt=\"post_topic.gif\"></p>\n<p>所有自动化测试的代码和测试用例都放在github上，网址在：\n<a href=\"https://github.com/CnodejsTest/UIAutoTest\">https://github.com/CnodejsTest/UIAutoTest</a></p>\n<p>感兴趣的只要拉下来，按照描述的步骤就可以运行了。</p>\n<h4><strong>星期日</strong></h4>\n<p>是我们自动化测试的开发日。上午10点乍浦路480号，同学们都到齐了。有一些手工测试的同学，一些自动化测试的同学。按照计划本次参与活动的同学有8名小伙伴公司做手工测试，4名小伙伴做自动化测试。他们当中有些知道行为驱动测试，有些还不知道这些概念。</p>\n<p>为了让大家能够很快的融入到一起敏捷开发，2名手工测试小伙伴与1名自动化测试小伙伴1组，手工测试的小伙伴写测试用例，自动化测试小伙伴写UI自动化脚本。位置安排是自动化测试小伙伴坐在中，手工测试小伙伴坐在两边，这样更易于他们沟通和学习。\n<img src=\"//dn-cnode.qbox.me/Fp7V6REPuxpmKBwTFtIJBDTqYYSr\" alt=\"QQ图片20180402180809.jpg\"></p>\n<h5><strong>上午</strong></h5>\n<p>上午主要是“统一思想，提高认识”，为了让所有人都了解开发的技术和方法。我们主要使用CukeTest客户端来阐释下行为驱动测试的概念。我们拿CNodeJS社区的“登录”场景为例，作为所有人的热身练习。</p>\n<p>开发的过程如下：先在CukeTest上写测试用例。用例也写的差不多的时候可以在CukeTest中一键生成自动化代码框架。然后实现这个框架。边填充代码，边在页面上定位元素。将元素定位的信息填充到代码中。我们知道，Selenium定位信息可以选ID, CSS, XPath等。当实现完这个测试用例就可点击运行。经过验证能够正常登陆。</p>\n<p>有些手动功能测试的小朋友从来没做过自动化测试的开发，但跟着自动化测试老司机们，也没过多久就写出来了。而且能够成功运行，登陆到测试的环境搭建的CNodeJS社区。有些不由的感叹自动化测试也可以这么简单。效果如下：\n<img src=\"//dn-cnode.qbox.me/FlUtA119-DW2fEUrmFOisNWQU93J\" alt=\"login.gif\"></p>\n<p>当这个场景完成后，通过CukeTest一键转换成“场景”大纲就可添加更多的测试数据了。\n不光有正确的用户名和密码登录，而且可以验证错误用户名和密码登录。这样一个测试场景就变成了n个:\n<img src=\"//dn-cnode.qbox.me/FhAfo8rm5CAGoHsFjm7_F90mlN-e\" alt=\"无标题.png\">\n上午主要就是开发登陆场景。由于大家都是临时过来，刚开始还是不是很熟练，经过几轮的协作，大家慢慢熟悉了开发流程。</p>\n<h5><strong>下午</strong></h5>\n<p>中午吃过饭，为提高效率，自动化测试小伙伴就单独出来去写UI自动化代码。功能测试小伙伴去学习一些基本的selenium-webdriver 知识，他们通过使用CukeTest生成的自动化代码，模仿之前的代码能够很快速的实现一个功能，大家都很开心。\n<img src=\"//dn-cnode.qbox.me/Fi67rWYhceKoLxeh4d1ZXgErEDkh\" alt=\"QQ图片20180402180816.jpg\">\n自动化同学相继开发出来测试脚本，所以晚些时候，主要调试自动化同学开发的脚本，并且对场景进行添加校验点。最终，我们实现了社区的用户注册，用户登录，发布话题，删除话题，收藏话题，回复话题的UI自动化。修改完成的脚本上传到GitHub代码库。</p>\n<p><strong>总结：</strong>\n通过这次沙龙，大家在一起协调的也非常好，大家也一起增长了测试经验，同时，也认识了新的朋友。更重要是，我们的自动化代码将会贡献给Cnode社区，造福大家。这里要感谢Cnode社区，提供一个这样的平台，并且鼓励我们。\n同时感谢CukeTest，提供工具能让我们很快的协助开发。也感谢猫叔，给我们提供场地，让我们能够坐在一起交流。\n<img src=\"//dn-cnode.qbox.me/Fv1tEGdM2ypy9hIkJwtKTWyDw7w_\" alt=\"QQ图片20180402180822.jpg\"></p>\n</div>",
          "title": "Node.JS自动化测试在CNode社区中的应用  -- CnodeJS线下沙龙活动",
          "last_reply_at": "2018-04-03T09:49:27.099Z",
          "good": true,
          "top": false,
          "reply_count": 13,
          "visit_count": 497,
          "create_at": "2018-04-02T10:39:24.179Z",
          "author": {
              "loginname": "imzengyang",
              "avatar_url": "https://avatars1.githubusercontent.com/u/22312483?v=4&s=120"
          }
      },
      {
          "id": "5ac34a8396f344940fbbacf4",
          "author_id": "5a1bc2b7110a338547d6e24a",
          "tab": "ask",
          "content": "<div class=\"markdown-text\"><p>刚刚需要把之前的项目从session转换到Token，express-jwt 与RedisJwt的结合有类似于Express session那样的（可以直接把session存到redis中的） 方 这里是把token存到Redis的法方法吗？</p>\n</div>",
          "title": "express-jwt 与RedisJwt的结合使用问题",
          "last_reply_at": "2018-04-03T09:33:55.286Z",
          "good": false,
          "top": false,
          "reply_count": 0,
          "visit_count": 126,
          "create_at": "2018-04-03T09:33:55.286Z",
          "author": {
              "loginname": "ray1888",
              "avatar_url": "https://avatars2.githubusercontent.com/u/19427008?v=4&s=120"
          }
      }
  ]
}